L1: 	<keyword, typedef>
L1: 	<keyword, struct>
L1: 	<identifier, huf>
L2: 	<brace, {>
L2: 	<keyword, int>
L2: 	<identifier, weight>
L2: 	<delimeter, ;>
L3: 	<keyword, int>
L3: 	<identifier, parent>
L3: 	<delimeter, ,>
L3: 	<identifier, lchild>
L3: 	<delimeter, ,>
L3: 	<identifier, rchild>
L3: 	<delimeter, ;>
L4: 	<brace, }>
L4: 	<identifier, HTNode>
L4: 	<delimeter, ,>
L4: 	<arith-op, *>
L4: 	<identifier, Huffmantree>
L4: 	<delimeter, ;>
L6: 	<identifier, FILE>
L6: 	<arith-op, *>
L6: 	<identifier, fptr>
L6: 	<assign-op, =>
L6: 	<identifier, NULL>
L6: 	<delimeter, ;>
L8: 	<identifier, Huffmantree>
L8: 	<identifier, HT>
L8: 	<assign-op, =>
L8: 	<identifier, NULL>
L8: 	<delimeter, ;>
L11: 	<keyword, int>
L11: 	<identifier, filetype>
L11: 	<brace, (>
L11: 	<keyword, char>
L11: 	<identifier, ch>
L11: 	<brace, [>
L11: 	<brace, ]>
L11: 	<brace, )>
L12: 	<brace, {>
L12: 	<keyword, int>
L12: 	<identifier, i>
L12: 	<assign-op, =>
L12: 	<integer, 0>
L12: 	<delimeter, ,>
L12: 	<identifier, n>
L12: 	<delimeter, ;>
L13: 	<keyword, while>
L13: 	<brace, (>
L13: 	<identifier, ch>
L13: 	<brace, [>
L13: 	<identifier, i>
L13: 	<brace, ]>
L13: 	<relop, !=>
L13: 	<char, '\0'>
L13: 	<brace, )>
L14: 	<brace, {>
L14: 	<keyword, if>
L14: 	<brace, (>
L14: 	<identifier, ch>
L14: 	<brace, [>
L14: 	<identifier, i>
L14: 	<brace, ]>
L14: 	<relop, ==>
L14: 	<char, '.'>
L14: 	<brace, )>
L15: 	<identifier, n>
L15: 	<assign-op, =>
L15: 	<identifier, i>
L15: 	<delimeter, ;>
L16: 	<identifier, i>
L16: 	<arith-op, ++>
L16: 	<delimeter, ;>
L16: 	<brace, }>
L17: 	<keyword, return>
L17: 	<identifier, n>
L17: 	<delimeter, ;>
L17: 	<brace, }>
L20: 	<keyword, void>
L20: 	<identifier, Select>
L20: 	<brace, (>
L20: 	<keyword, int>
L20: 	<identifier, n>
L20: 	<delimeter, ,>
L20: 	<keyword, int>
L20: 	<arith-op, *>
L20: 	<identifier, s1>
L20: 	<delimeter, ,>
L20: 	<keyword, int>
L20: 	<arith-op, *>
L20: 	<identifier, s2>
L20: 	<brace, )>
L21: 	<brace, {>
L21: 	<keyword, int>
L21: 	<identifier, i>
L21: 	<delimeter, ,>
L21: 	<identifier, temp>
L21: 	<delimeter, ;>
L22: 	<keyword, for>
L22: 	<brace, (>
L22: 	<identifier, i>
L22: 	<assign-op, =>
L22: 	<integer, 0>
L22: 	<delimeter, ;>
L22: 	<identifier, i>
L22: 	<relop, <=>
L22: 	<identifier, n>
L22: 	<delimeter, ;>
L22: 	<identifier, i>
L22: 	<arith-op, ++>
L22: 	<brace, )>
L23: 	<keyword, if>
L23: 	<brace, (>
L23: 	<identifier, HT>
L23: 	<brace, [>
L23: 	<identifier, i>
L23: 	<brace, ]>
L23: 	<postfix operator, .>
L23: 	<identifier, weight>
L23: 	<relop, >>
L23: 	<integer, 0>
L23: 	<logic-op, &&>
L23: 	<identifier, HT>
L23: 	<brace, [>
L23: 	<identifier, i>
L23: 	<brace, ]>
L23: 	<postfix operator, .>
L23: 	<identifier, parent>
L23: 	<relop, ==>
L23: 	<arith-op, ->
L23: 	<integer, 1>
L23: 	<brace, )>
L24: 	<brace, {>
L24: 	<arith-op, *>
L24: 	<identifier, s1>
L24: 	<assign-op, =>
L24: 	<identifier, i>
L24: 	<delimeter, ;>
L25: 	<keyword, break>
L25: 	<delimeter, ;>
L25: 	<brace, }>
L26: 	<keyword, for>
L26: 	<brace, (>
L26: 	<identifier, i>
L26: 	<assign-op, =>
L26: 	<identifier, i>
L26: 	<arith-op, +>
L26: 	<integer, 1>
L26: 	<delimeter, ;>
L26: 	<identifier, i>
L26: 	<relop, <=>
L26: 	<identifier, n>
L26: 	<delimeter, ;>
L26: 	<identifier, i>
L26: 	<arith-op, ++>
L26: 	<brace, )>
L27: 	<brace, {>
L27: 	<keyword, if>
L27: 	<brace, (>
L27: 	<identifier, HT>
L27: 	<brace, [>
L27: 	<identifier, i>
L27: 	<brace, ]>
L27: 	<postfix operator, .>
L27: 	<identifier, weight>
L27: 	<relop, >>
L27: 	<integer, 0>
L27: 	<logic-op, &&>
L27: 	<identifier, HT>
L27: 	<brace, [>
L27: 	<identifier, i>
L27: 	<brace, ]>
L27: 	<postfix operator, .>
L27: 	<identifier, parent>
L27: 	<relop, ==>
L27: 	<arith-op, ->
L27: 	<integer, 1>
L27: 	<brace, )>
L28: 	<brace, {>
L28: 	<arith-op, *>
L28: 	<identifier, s2>
L28: 	<assign-op, =>
L28: 	<identifier, i>
L28: 	<delimeter, ;>
L29: 	<keyword, break>
L29: 	<delimeter, ;>
L29: 	<brace, }>
L30: 	<brace, }>
L31: 	<keyword, if>
L31: 	<brace, (>
L31: 	<identifier, HT>
L31: 	<brace, [>
L31: 	<arith-op, *>
L31: 	<identifier, s2>
L31: 	<brace, ]>
L31: 	<postfix operator, .>
L31: 	<identifier, weight>
L31: 	<relop, <>
L31: 	<identifier, HT>
L31: 	<brace, [>
L31: 	<arith-op, *>
L31: 	<identifier, s1>
L31: 	<brace, ]>
L31: 	<postfix operator, .>
L31: 	<identifier, weight>
L31: 	<brace, )>
L32: 	<brace, {>
L32: 	<identifier, temp>
L32: 	<assign-op, =>
L32: 	<arith-op, *>
L32: 	<identifier, s1>
L32: 	<delimeter, ;>
L33: 	<arith-op, *>
L33: 	<identifier, s1>
L33: 	<assign-op, =>
L33: 	<arith-op, *>
L33: 	<identifier, s2>
L33: 	<delimeter, ;>
L34: 	<arith-op, *>
L34: 	<identifier, s2>
L34: 	<assign-op, =>
L34: 	<identifier, temp>
L34: 	<delimeter, ;>
L35: 	<brace, }>
L36: 	<keyword, for>
L36: 	<brace, (>
L36: 	<identifier, i>
L36: 	<assign-op, =>
L36: 	<identifier, i>
L36: 	<arith-op, +>
L36: 	<integer, 1>
L36: 	<delimeter, ;>
L36: 	<identifier, i>
L36: 	<relop, <=>
L36: 	<identifier, n>
L36: 	<delimeter, ;>
L36: 	<identifier, i>
L36: 	<arith-op, ++>
L36: 	<brace, )>
L37: 	<keyword, if>
L37: 	<brace, (>
L37: 	<identifier, HT>
L37: 	<brace, [>
L37: 	<identifier, i>
L37: 	<brace, ]>
L37: 	<postfix operator, .>
L37: 	<identifier, weight>
L37: 	<relop, >>
L37: 	<integer, 0>
L37: 	<logic-op, &&>
L37: 	<identifier, HT>
L37: 	<brace, [>
L37: 	<identifier, i>
L37: 	<brace, ]>
L37: 	<postfix operator, .>
L37: 	<identifier, parent>
L37: 	<relop, ==>
L37: 	<arith-op, ->
L37: 	<integer, 1>
L37: 	<brace, )>
L38: 	<keyword, if>
L38: 	<brace, (>
L38: 	<identifier, HT>
L38: 	<brace, [>
L38: 	<identifier, i>
L38: 	<brace, ]>
L38: 	<postfix operator, .>
L38: 	<identifier, weight>
L38: 	<relop, <>
L38: 	<identifier, HT>
L38: 	<brace, [>
L38: 	<arith-op, *>
L38: 	<identifier, s1>
L38: 	<brace, ]>
L38: 	<postfix operator, .>
L38: 	<identifier, weight>
L38: 	<brace, )>
L39: 	<brace, {>
L39: 	<arith-op, *>
L39: 	<identifier, s2>
L39: 	<assign-op, =>
L39: 	<arith-op, *>
L39: 	<identifier, s1>
L39: 	<delimeter, ;>
L40: 	<arith-op, *>
L40: 	<identifier, s1>
L40: 	<assign-op, =>
L40: 	<identifier, i>
L40: 	<delimeter, ;>
L40: 	<brace, }>
L41: 	<keyword, else>
L41: 	<keyword, if>
L41: 	<brace, (>
L41: 	<identifier, HT>
L41: 	<brace, [>
L41: 	<identifier, i>
L41: 	<brace, ]>
L41: 	<postfix operator, .>
L41: 	<identifier, weight>
L41: 	<relop, <>
L41: 	<identifier, HT>
L41: 	<brace, [>
L41: 	<arith-op, *>
L41: 	<identifier, s2>
L41: 	<brace, ]>
L41: 	<postfix operator, .>
L41: 	<identifier, weight>
L41: 	<brace, )>
L42: 	<arith-op, *>
L42: 	<identifier, s2>
L42: 	<assign-op, =>
L42: 	<identifier, i>
L42: 	<delimeter, ;>
L43: 	<keyword, return>
L43: 	<delimeter, ;>
L44: 	<brace, }>
L47: 	<keyword, int>
L47: 	<identifier, CreateHuffmantree>
L47: 	<brace, (>
L47: 	<keyword, char>
L47: 	<identifier, filename>
L47: 	<brace, [>
L47: 	<brace, ]>
L47: 	<brace, )>
L48: 	<brace, {>
L48: 	<keyword, int>
L48: 	<identifier, i>
L48: 	<delimeter, ,>
L48: 	<identifier, k>
L48: 	<delimeter, ,>
L48: 	<identifier, n>
L48: 	<assign-op, =>
L48: 	<integer, 0>
L48: 	<delimeter, ;>
L49: 	<keyword, int>
L49: 	<identifier, s1>
L49: 	<delimeter, ,>
L49: 	<identifier, s2>
L49: 	<delimeter, ;>
L50: 	<identifier, HT>
L50: 	<assign-op, =>
L50: 	<brace, (>
L50: 	<identifier, Huffmantree>
L50: 	<brace, )>
L50: 	<identifier, malloc>
L50: 	<brace, (>
L50: 	<keyword, sizeof>
L50: 	<brace, (>
L50: 	<identifier, HTNode>
L50: 	<brace, )>
L50: 	<arith-op, *>
L50: 	<integer, 512>
L50: 	<brace, )>
L50: 	<delimeter, ;>
L51: 	<keyword, if>
L51: 	<brace, (>
L51: 	<brace, (>
L51: 	<identifier, fptr>
L51: 	<assign-op, =>
L51: 	<identifier, fopen>
L51: 	<brace, (>
L51: 	<identifier, filename>
L51: 	<delimeter, ,>
L51: 	<string, "rb">
L51: 	<brace, )>
L51: 	<brace, )>
L51: 	<relop, ==>
L51: 	<identifier, NULL>
L51: 	<brace, )>
L52: 	<brace, {>
L52: 	<identifier, printf>
L52: 	<brace, (>
L52: 	<string, "can't open the source file\n">
L52: 	<brace, )>
L52: 	<delimeter, ;>
L53: 	<keyword, return>
L53: 	<integer, 0>
L53: 	<delimeter, ;>
L53: 	<brace, }>
L54: 	<keyword, for>
L54: 	<brace, (>
L54: 	<identifier, i>
L54: 	<assign-op, =>
L54: 	<integer, 0>
L54: 	<delimeter, ;>
L54: 	<identifier, i>
L54: 	<relop, <=>
L54: 	<integer, 255>
L54: 	<delimeter, ;>
L54: 	<identifier, i>
L54: 	<arith-op, ++>
L54: 	<brace, )>
L55: 	<brace, {>
L55: 	<identifier, HT>
L55: 	<brace, [>
L55: 	<identifier, i>
L55: 	<brace, ]>
L55: 	<postfix operator, .>
L55: 	<identifier, parent>
L55: 	<assign-op, =>
L55: 	<identifier, HT>
L55: 	<brace, [>
L55: 	<identifier, i>
L55: 	<brace, ]>
L55: 	<postfix operator, .>
L55: 	<identifier, lchild>
L55: 	<assign-op, =>
L55: 	<identifier, HT>
L55: 	<brace, [>
L55: 	<identifier, i>
L55: 	<brace, ]>
L55: 	<postfix operator, .>
L55: 	<identifier, rchild>
L55: 	<assign-op, =>
L55: 	<arith-op, ->
L55: 	<integer, 1>
L55: 	<delimeter, ;>
L56: 	<identifier, HT>
L56: 	<brace, [>
L56: 	<identifier, i>
L56: 	<brace, ]>
L56: 	<postfix operator, .>
L56: 	<identifier, weight>
L56: 	<assign-op, =>
L56: 	<integer, 0>
L56: 	<delimeter, ;>
L56: 	<brace, }>
L57: 	<keyword, while>
L57: 	<brace, (>
L57: 	<brace, (>
L57: 	<identifier, k>
L57: 	<assign-op, =>
L57: 	<identifier, fgetc>
L57: 	<brace, (>
L57: 	<identifier, fptr>
L57: 	<brace, )>
L57: 	<brace, )>
L57: 	<relop, !=>
L57: 	<identifier, EOF>
L57: 	<brace, )>
L58: 	<brace, {>
L58: 	<keyword, if>
L58: 	<brace, (>
L58: 	<identifier, HT>
L58: 	<brace, [>
L58: 	<identifier, k>
L58: 	<brace, ]>
L58: 	<postfix operator, .>
L58: 	<identifier, weight>
L58: 	<relop, ==>
L58: 	<integer, 0>
L58: 	<brace, )>
L59: 	<identifier, n>
L59: 	<arith-op, ++>
L59: 	<delimeter, ;>
L60: 	<identifier, HT>
L60: 	<brace, [>
L60: 	<identifier, k>
L60: 	<brace, ]>
L60: 	<postfix operator, .>
L60: 	<identifier, weight>
L60: 	<arith-op, ++>
L60: 	<delimeter, ;>
L61: 	<brace, }>
L62: 	<identifier, rewind>
L62: 	<brace, (>
L62: 	<identifier, fptr>
L62: 	<brace, )>
L62: 	<delimeter, ;>
L63: 	<keyword, for>
L63: 	<brace, (>
L63: 	<identifier, i>
L63: 	<assign-op, =>
L63: 	<integer, 256>
L63: 	<delimeter, ;>
L63: 	<identifier, i>
L63: 	<relop, <>
L63: 	<integer, 256>
L63: 	<arith-op, +>
L63: 	<identifier, n>
L63: 	<arith-op, ->
L63: 	<integer, 1>
L63: 	<delimeter, ;>
L63: 	<identifier, i>
L63: 	<arith-op, ++>
L63: 	<brace, )>
L64: 	<brace, {>
L64: 	<identifier, Select>
L64: 	<brace, (>
L64: 	<identifier, i>
L64: 	<arith-op, ->
L64: 	<integer, 1>
L64: 	<delimeter, ,>
L64: 	<bitop, &>
L64: 	<identifier, s1>
L64: 	<delimeter, ,>
L64: 	<bitop, &>
L64: 	<identifier, s2>
L64: 	<brace, )>
L64: 	<delimeter, ;>
L65: 	<identifier, HT>
L65: 	<brace, [>
L65: 	<identifier, s1>
L65: 	<brace, ]>
L65: 	<postfix operator, .>
L65: 	<identifier, parent>
L65: 	<assign-op, =>
L65: 	<identifier, i>
L65: 	<delimeter, ;>
L66: 	<identifier, HT>
L66: 	<brace, [>
L66: 	<identifier, s2>
L66: 	<brace, ]>
L66: 	<postfix operator, .>
L66: 	<identifier, parent>
L66: 	<assign-op, =>
L66: 	<identifier, i>
L66: 	<delimeter, ;>
L67: 	<identifier, HT>
L67: 	<brace, [>
L67: 	<identifier, i>
L67: 	<brace, ]>
L67: 	<postfix operator, .>
L67: 	<identifier, lchild>
L67: 	<assign-op, =>
L67: 	<identifier, s1>
L67: 	<delimeter, ;>
L68: 	<identifier, HT>
L68: 	<brace, [>
L68: 	<identifier, i>
L68: 	<brace, ]>
L68: 	<postfix operator, .>
L68: 	<identifier, rchild>
L68: 	<assign-op, =>
L68: 	<identifier, s2>
L68: 	<delimeter, ;>
L69: 	<identifier, HT>
L69: 	<brace, [>
L69: 	<identifier, i>
L69: 	<brace, ]>
L69: 	<postfix operator, .>
L69: 	<identifier, weight>
L69: 	<assign-op, =>
L69: 	<identifier, HT>
L69: 	<brace, [>
L69: 	<identifier, s1>
L69: 	<brace, ]>
L69: 	<postfix operator, .>
L69: 	<identifier, weight>
L69: 	<arith-op, +>
L69: 	<identifier, HT>
L69: 	<brace, [>
L69: 	<identifier, s2>
L69: 	<brace, ]>
L69: 	<postfix operator, .>
L69: 	<identifier, weight>
L69: 	<delimeter, ;>
L70: 	<identifier, HT>
L70: 	<brace, [>
L70: 	<identifier, i>
L70: 	<brace, ]>
L70: 	<postfix operator, .>
L70: 	<identifier, parent>
L70: 	<assign-op, =>
L70: 	<arith-op, ->
L70: 	<integer, 1>
L70: 	<delimeter, ;>
L71: 	<brace, }>
L72: 	<keyword, return>
L72: 	<identifier, n>
L72: 	<delimeter, ;>
L73: 	<brace, }>
L76: 	<keyword, char>
L76: 	<arith-op, *>
L76: 	<arith-op, *>
L76: 	<identifier, CreateHuffmancode>
L76: 	<brace, (>
L76: 	<keyword, int>
L76: 	<identifier, n>
L76: 	<brace, )>
L77: 	<brace, {>
L77: 	<keyword, int>
L77: 	<identifier, i>
L77: 	<delimeter, ,>
L77: 	<identifier, j>
L77: 	<delimeter, ,>
L77: 	<identifier, start>
L77: 	<delimeter, ,>
L77: 	<identifier, pre>
L77: 	<delimeter, ;>
L78: 	<keyword, char>
L78: 	<arith-op, *>
L78: 	<arith-op, *>
L78: 	<identifier, HC>
L78: 	<assign-op, =>
L78: 	<brace, (>
L78: 	<keyword, char>
L78: 	<arith-op, *>
L78: 	<arith-op, *>
L78: 	<brace, )>
L78: 	<identifier, malloc>
L78: 	<brace, (>
L78: 	<keyword, sizeof>
L78: 	<brace, (>
L78: 	<keyword, char>
L78: 	<arith-op, *>
L78: 	<brace, )>
L78: 	<arith-op, *>
L78: 	<integer, 256>
L78: 	<brace, )>
L78: 	<delimeter, ;>
L79: 	<keyword, for>
L79: 	<brace, (>
L79: 	<identifier, i>
L79: 	<assign-op, =>
L79: 	<integer, 0>
L79: 	<delimeter, ;>
L79: 	<identifier, i>
L79: 	<relop, <>
L79: 	<integer, 256>
L79: 	<delimeter, ;>
L79: 	<identifier, i>
L79: 	<arith-op, ++>
L79: 	<brace, )>
L80: 	<identifier, HC>
L80: 	<brace, [>
L80: 	<identifier, i>
L80: 	<brace, ]>
L80: 	<assign-op, =>
L80: 	<brace, (>
L80: 	<keyword, char>
L80: 	<arith-op, *>
L80: 	<brace, )>
L80: 	<identifier, malloc>
L80: 	<brace, (>
L80: 	<keyword, sizeof>
L80: 	<brace, (>
L80: 	<keyword, char>
L80: 	<brace, )>
L80: 	<arith-op, *>
L80: 	<brace, (>
L80: 	<identifier, n>
L80: 	<arith-op, +>
L80: 	<integer, 1>
L80: 	<brace, )>
L80: 	<brace, )>
L80: 	<delimeter, ;>
L81: 	<keyword, char>
L81: 	<identifier, cd>
L81: 	<brace, [>
L81: 	<identifier, n>
L81: 	<brace, ]>
L81: 	<delimeter, ;>
L82: 	<identifier, cd>
L82: 	<brace, [>
L82: 	<identifier, n>
L82: 	<arith-op, ->
L82: 	<integer, 1>
L82: 	<brace, ]>
L82: 	<assign-op, =>
L82: 	<char, '\0'>
L82: 	<delimeter, ;>
L84: 	<keyword, for>
L84: 	<brace, (>
L84: 	<identifier, i>
L84: 	<assign-op, =>
L84: 	<integer, 0>
L84: 	<delimeter, ;>
L84: 	<identifier, i>
L84: 	<relop, <=>
L84: 	<integer, 255>
L84: 	<delimeter, ;>
L84: 	<identifier, i>
L84: 	<arith-op, ++>
L84: 	<brace, )>
L85: 	<brace, {>
L85: 	<keyword, if>
L85: 	<brace, (>
L85: 	<identifier, HT>
L85: 	<brace, [>
L85: 	<identifier, i>
L85: 	<brace, ]>
L85: 	<postfix operator, .>
L85: 	<identifier, weight>
L85: 	<relop, ==>
L85: 	<integer, 0>
L85: 	<brace, )>
L86: 	<identifier, HC>
L86: 	<brace, [>
L86: 	<identifier, i>
L86: 	<brace, ]>
L86: 	<assign-op, =>
L86: 	<char, '\0'>
L86: 	<delimeter, ;>
L87: 	<keyword, else>
L88: 	<brace, {>
L88: 	<identifier, start>
L88: 	<assign-op, =>
L88: 	<identifier, n>
L88: 	<arith-op, ->
L88: 	<integer, 1>
L88: 	<delimeter, ;>
L89: 	<identifier, j>
L89: 	<assign-op, =>
L89: 	<identifier, i>
L89: 	<delimeter, ;>
L90: 	<identifier, pre>
L90: 	<assign-op, =>
L90: 	<identifier, HT>
L90: 	<brace, [>
L90: 	<identifier, j>
L90: 	<brace, ]>
L90: 	<postfix operator, .>
L90: 	<identifier, parent>
L90: 	<delimeter, ;>
L91: 	<keyword, while>
L91: 	<brace, (>
L91: 	<identifier, pre>
L91: 	<relop, !=>
L91: 	<arith-op, ->
L91: 	<integer, 1>
L91: 	<brace, )>
L92: 	<brace, {>
L92: 	<identifier, start>
L92: 	<arith-op, -->
L92: 	<delimeter, ;>
L93: 	<keyword, if>
L93: 	<brace, (>
L93: 	<identifier, HT>
L93: 	<brace, [>
L93: 	<identifier, pre>
L93: 	<brace, ]>
L93: 	<postfix operator, .>
L93: 	<identifier, lchild>
L93: 	<relop, ==>
L93: 	<identifier, j>
L93: 	<brace, )>
L94: 	<identifier, cd>
L94: 	<brace, [>
L94: 	<identifier, start>
L94: 	<brace, ]>
L94: 	<assign-op, =>
L94: 	<char, '0'>
L94: 	<delimeter, ;>
L95: 	<keyword, else>
L96: 	<identifier, cd>
L96: 	<brace, [>
L96: 	<identifier, start>
L96: 	<brace, ]>
L96: 	<assign-op, =>
L96: 	<char, '1'>
L96: 	<delimeter, ;>
L97: 	<identifier, j>
L97: 	<assign-op, =>
L97: 	<identifier, pre>
L97: 	<delimeter, ;>
L98: 	<identifier, pre>
L98: 	<assign-op, =>
L98: 	<identifier, HT>
L98: 	<brace, [>
L98: 	<identifier, j>
L98: 	<brace, ]>
L98: 	<postfix operator, .>
L98: 	<identifier, parent>
L98: 	<delimeter, ;>
L99: 	<brace, }>
L100: 	<identifier, strcpy>
L100: 	<brace, (>
L100: 	<identifier, HC>
L100: 	<brace, [>
L100: 	<identifier, i>
L100: 	<brace, ]>
L100: 	<delimeter, ,>
L100: 	<bitop, &>
L100: 	<identifier, cd>
L100: 	<brace, [>
L100: 	<identifier, start>
L100: 	<brace, ]>
L100: 	<brace, )>
L100: 	<delimeter, ;>
L101: 	<brace, }>
L102: 	<brace, }>
L103: 	<keyword, return>
L103: 	<identifier, HC>
L103: 	<delimeter, ;>
L104: 	<brace, }>
L106: 	<keyword, void>
L106: 	<identifier, Huffmandecoding>
L106: 	<brace, (>
L106: 	<identifier, FILE>
L106: 	<arith-op, *>
L106: 	<identifier, fptr1>
L106: 	<delimeter, ,>
L106: 	<keyword, int>
L106: 	<identifier, num>
L106: 	<delimeter, ,>
L106: 	<keyword, int>
L106: 	<identifier, pos>
L106: 	<delimeter, ,>
L106: 	<keyword, char>
L106: 	<arith-op, *>
L106: 	<identifier, filename>
L106: 	<delimeter, ,>
L106: 	<keyword, int>
L106: 	<identifier, k>
L106: 	<brace, )>
L107: 	<brace, {>
L107: 	<identifier, rewind>
L107: 	<brace, (>
L107: 	<identifier, fptr1>
L107: 	<brace, )>
L107: 	<delimeter, ;>
L108: 	<identifier, FILE>
L108: 	<arith-op, *>
L108: 	<identifier, fptr2>
L108: 	<delimeter, ;>
L109: 	<keyword, char>
L109: 	<identifier, objectfile>
L109: 	<brace, [>
L109: 	<integer, 10>
L109: 	<brace, ]>
L109: 	<assign-op, =>
L109: 	<string, "out2">
L109: 	<delimeter, ;>
L110: 	<identifier, strcat>
L110: 	<brace, (>
L110: 	<identifier, objectfile>
L110: 	<delimeter, ,>
L110: 	<bitop, &>
L110: 	<identifier, filename>
L110: 	<brace, [>
L110: 	<identifier, k>
L110: 	<brace, ]>
L110: 	<brace, )>
L110: 	<delimeter, ;>
L110: 	<delimeter, ;>
L111: 	<keyword, if>
L111: 	<brace, (>
L111: 	<brace, (>
L111: 	<identifier, fptr2>
L111: 	<assign-op, =>
L111: 	<identifier, fopen>
L111: 	<brace, (>
L111: 	<identifier, objectfile>
L111: 	<delimeter, ,>
L111: 	<string, "wb">
L111: 	<brace, )>
L111: 	<brace, )>
L111: 	<relop, ==>
L111: 	<identifier, NULL>
L111: 	<brace, )>
L112: 	<identifier, printf>
L112: 	<brace, (>
L112: 	<string, "can't open the object file\n">
L112: 	<brace, )>
L112: 	<delimeter, ;>
L113: 	<keyword, int>
L113: 	<identifier, c>
L113: 	<delimeter, ;>
L114: 	<keyword, int>
L114: 	<identifier, i>
L114: 	<delimeter, ,>
L114: 	<identifier, j>
L114: 	<delimeter, ,>
L114: 	<identifier, m>
L114: 	<delimeter, ,>
L114: 	<identifier, p>
L114: 	<delimeter, ,>
L114: 	<identifier, weight>
L114: 	<delimeter, ;>
L115: 	<keyword, for>
L115: 	<brace, (>
L115: 	<identifier, i>
L115: 	<assign-op, =>
L115: 	<integer, 0>
L115: 	<delimeter, ;>
L115: 	<identifier, i>
L115: 	<relop, <=>
L115: 	<integer, 512>
L115: 	<delimeter, ;>
L115: 	<identifier, i>
L115: 	<arith-op, ++>
L115: 	<brace, )>
L116: 	<keyword, if>
L116: 	<brace, (>
L116: 	<brace, (>
L116: 	<identifier, HT>
L116: 	<brace, [>
L116: 	<identifier, i>
L116: 	<brace, ]>
L116: 	<postfix operator, .>
L116: 	<identifier, parent>
L116: 	<relop, ==>
L116: 	<arith-op, ->
L116: 	<integer, 1>
L116: 	<brace, )>
L116: 	<logic-op, &&>
L116: 	<identifier, HT>
L116: 	<brace, [>
L116: 	<identifier, i>
L116: 	<brace, ]>
L116: 	<postfix operator, .>
L116: 	<identifier, weight>
L116: 	<relop, >>
L116: 	<integer, 0>
L116: 	<brace, )>
L117: 	<keyword, break>
L117: 	<delimeter, ;>
L118: 	<identifier, p>
L118: 	<assign-op, =>
L118: 	<identifier, i>
L118: 	<delimeter, ;>
L119: 	<keyword, while>
L119: 	<brace, (>
L119: 	<brace, (>
L119: 	<identifier, c>
L119: 	<assign-op, =>
L119: 	<identifier, fgetc>
L119: 	<brace, (>
L119: 	<identifier, fptr1>
L119: 	<brace, )>
L119: 	<brace, )>
L119: 	<relop, !=>
L119: 	<identifier, EOF>
L119: 	<brace, )>
L120: 	<brace, {>
L120: 	<identifier, num>
L120: 	<arith-op, -->
L120: 	<delimeter, ;>
L121: 	<keyword, for>
L121: 	<brace, (>
L121: 	<identifier, weight>
L121: 	<assign-op, =>
L121: 	<integer, 128>
L121: 	<delimeter, ;>
L121: 	<identifier, weight>
L121: 	<relop, >>
L121: 	<integer, 0>
L121: 	<delimeter, ;>
L121: 	<identifier, weight>
L121: 	<assign-op, =>
L121: 	<identifier, weight>
L121: 	<arith-op, />
L121: 	<integer, 2>
L121: 	<brace, )>
L122: 	<brace, {>
L122: 	<identifier, m>
L122: 	<assign-op, =>
L122: 	<identifier, c>
L122: 	<arith-op, />
L122: 	<identifier, weight>
L122: 	<delimeter, ;>
L123: 	<identifier, c>
L123: 	<assign-op, =>
L123: 	<identifier, c>
L123: 	<arith-op, %>
L123: 	<identifier, weight>
L123: 	<delimeter, ;>
L124: 	<keyword, if>
L124: 	<brace, (>
L124: 	<identifier, m>
L124: 	<relop, ==>
L124: 	<integer, 0>
L124: 	<brace, )>
L125: 	<identifier, p>
L125: 	<assign-op, =>
L125: 	<identifier, HT>
L125: 	<brace, [>
L125: 	<identifier, p>
L125: 	<brace, ]>
L125: 	<postfix operator, .>
L125: 	<identifier, lchild>
L125: 	<delimeter, ;>
L126: 	<keyword, if>
L126: 	<brace, (>
L126: 	<identifier, m>
L126: 	<relop, ==>
L126: 	<integer, 1>
L126: 	<brace, )>
L127: 	<identifier, p>
L127: 	<assign-op, =>
L127: 	<identifier, HT>
L127: 	<brace, [>
L127: 	<identifier, p>
L127: 	<brace, ]>
L127: 	<postfix operator, .>
L127: 	<identifier, rchild>
L127: 	<delimeter, ;>
L128: 	<keyword, if>
L128: 	<brace, (>
L128: 	<identifier, HT>
L128: 	<brace, [>
L128: 	<identifier, p>
L128: 	<brace, ]>
L128: 	<postfix operator, .>
L128: 	<identifier, lchild>
L128: 	<relop, ==>
L128: 	<arith-op, ->
L128: 	<integer, 1>
L128: 	<logic-op, &&>
L128: 	<identifier, HT>
L128: 	<brace, [>
L128: 	<identifier, p>
L128: 	<brace, ]>
L128: 	<postfix operator, .>
L128: 	<identifier, rchild>
L128: 	<relop, ==>
L128: 	<arith-op, ->
L128: 	<integer, 1>
L128: 	<brace, )>
L129: 	<brace, {>
L129: 	<identifier, fputc>
L129: 	<brace, (>
L129: 	<identifier, p>
L129: 	<delimeter, ,>
L129: 	<identifier, fptr2>
L129: 	<brace, )>
L129: 	<delimeter, ;>
L130: 	<identifier, p>
L130: 	<assign-op, =>
L130: 	<identifier, i>
L130: 	<delimeter, ;>
L131: 	<keyword, if>
L131: 	<brace, (>
L131: 	<identifier, num>
L131: 	<relop, ==>
L131: 	<arith-op, ->
L131: 	<integer, 1>
L131: 	<logic-op, &&>
L131: 	<identifier, weight>
L131: 	<relop, ==>
L131: 	<identifier, pos>
L131: 	<arith-op, *>
L131: 	<integer, 2>
L131: 	<brace, )>
L132: 	<keyword, break>
L132: 	<delimeter, ;>
L132: 	<brace, }>
L133: 	<brace, }>
L134: 	<brace, }>
L135: 	<identifier, printf>
L135: 	<brace, (>
L135: 	<string, "哈夫曼编码结束, 输出到文件">
L135: 	<brace, )>
L135: 	<delimeter, ;>
L136: 	<identifier, fclose>
L136: 	<brace, (>
L136: 	<identifier, fptr2>
L136: 	<brace, )>
L136: 	<delimeter, ;>
L137: 	<keyword, return>
L137: 	<delimeter, ;>
L138: 	<brace, }>
L140: 	<keyword, int>
L140: 	<identifier, main>
L140: 	<brace, (>
L140: 	<keyword, void>
L140: 	<brace, )>
L141: 	<brace, {>
L141: 	<keyword, int>
L141: 	<identifier, n>
L141: 	<delimeter, ,>
L141: 	<identifier, i>
L141: 	<delimeter, ,>
L141: 	<identifier, j>
L141: 	<delimeter, ,>
L141: 	<identifier, k>
L141: 	<delimeter, ,>
L141: 	<identifier, weight>
L141: 	<delimeter, ,>
L141: 	<identifier, pos>
L141: 	<delimeter, ,>
L141: 	<identifier, num>
L141: 	<assign-op, =>
L141: 	<integer, 0>
L141: 	<delimeter, ;>
L142: 	<keyword, char>
L142: 	<identifier, c>
L142: 	<delimeter, ,>
L142: 	<identifier, ch>
L142: 	<delimeter, ;>
L143: 	<keyword, char>
L143: 	<arith-op, *>
L143: 	<arith-op, *>
L143: 	<identifier, HC>
L143: 	<delimeter, ;>
L144: 	<identifier, FILE>
L144: 	<arith-op, *>
L144: 	<identifier, fptr0>
L144: 	<delimeter, ;>
L145: 	<identifier, FILE>
L145: 	<arith-op, *>
L145: 	<identifier, fptr1>
L145: 	<delimeter, ;>
L146: 	<keyword, if>
L146: 	<brace, (>
L146: 	<brace, (>
L146: 	<identifier, fptr0>
L146: 	<assign-op, =>
L146: 	<identifier, fopen>
L146: 	<brace, (>
L146: 	<string, "out0.txt","w+">
L146: 	<brace, )>
L146: 	<brace, )>
L146: 	<relop, ==>
L146: 	<identifier, NULL>
L146: 	<brace, )>
L147: 	<identifier, printf>
L147: 	<brace, (>
L147: 	<string, "can't open the object file\n">
L147: 	<brace, )>
L147: 	<delimeter, ;>
L148: 	<keyword, if>
L148: 	<brace, (>
L148: 	<brace, (>
L148: 	<identifier, fptr1>
L148: 	<assign-op, =>
L148: 	<identifier, fopen>
L148: 	<brace, (>
L148: 	<string, "out1.txt","wb+">
L148: 	<brace, )>
L148: 	<brace, )>
L148: 	<relop, ==>
L148: 	<identifier, NULL>
L148: 	<brace, )>
L149: 	<identifier, printf>
L149: 	<brace, (>
L149: 	<string, "can't open the object file\n">
L149: 	<brace, )>
L149: 	<delimeter, ;>
L150: 	<identifier, printf>
L150: 	<brace, (>
L150: 	<string, "对象文件无法打开">
L150: 	<brace, )>
L150: 	<delimeter, ;>
L151: 	<keyword, char>
L151: 	<identifier, filename>
L151: 	<brace, [>
L151: 	<integer, 100>
L151: 	<brace, ]>
L151: 	<delimeter, ;>
L152: 	<identifier, gets>
L152: 	<brace, (>
L152: 	<identifier, filename>
L152: 	<brace, )>
L152: 	<delimeter, ;>
L153: 	<identifier, n>
L153: 	<assign-op, =>
L153: 	<identifier, CreateHuffmantree>
L153: 	<brace, (>
L153: 	<identifier, filename>
L153: 	<brace, )>
L153: 	<delimeter, ;>
L154: 	<keyword, if>
L154: 	<brace, (>
L154: 	<identifier, n>
L154: 	<relop, ==>
L154: 	<integer, 0>
L154: 	<brace, )>
L155: 	<keyword, return>
L155: 	<integer, 0>
L155: 	<delimeter, ;>
L156: 	<keyword, if>
L156: 	<brace, (>
L156: 	<identifier, n>
L156: 	<relop, ==>
L156: 	<integer, 1>
L156: 	<brace, )>
L157: 	<brace, {>
L157: 	<identifier, rewind>
L157: 	<brace, (>
L157: 	<identifier, fptr>
L157: 	<brace, )>
L157: 	<delimeter, ;>
L158: 	<keyword, while>
L158: 	<brace, (>
L158: 	<brace, (>
L158: 	<identifier, c>
L158: 	<assign-op, =>
L158: 	<identifier, fgetc>
L158: 	<brace, (>
L158: 	<identifier, fptr>
L158: 	<brace, )>
L158: 	<brace, )>
L158: 	<relop, !=>
L158: 	<identifier, EOF>
L158: 	<brace, )>
L159: 	<brace, {>
L159: 	<identifier, k>
L159: 	<arith-op, ++>
L159: 	<delimeter, ;>
L160: 	<identifier, ch>
L160: 	<assign-op, =>
L160: 	<identifier, c>
L160: 	<delimeter, ;>
L161: 	<identifier, fputc>
L161: 	<brace, (>
L161: 	<char, '0'>
L161: 	<delimeter, ,>
L161: 	<identifier, fptr0>
L161: 	<brace, )>
L161: 	<delimeter, ;>
L162: 	<keyword, if>
L162: 	<brace, (>
L162: 	<identifier, k>
L162: 	<arith-op, %>
L162: 	<integer, 8>
L162: 	<relop, ==>
L162: 	<integer, 0>
L162: 	<brace, )>
L163: 	<identifier, fputc>
L163: 	<brace, (>
L163: 	<brace, (>
L163: 	<keyword, char>
L163: 	<brace, )>
L163: 	<integer, 0>
L163: 	<delimeter, ,>
L163: 	<identifier, fptr1>
L163: 	<brace, )>
L163: 	<delimeter, ;>
L163: 	<brace, }>
L164: 	<identifier, fputc>
L164: 	<brace, (>
L164: 	<brace, (>
L164: 	<keyword, char>
L164: 	<brace, )>
L164: 	<integer, 0>
L164: 	<delimeter, ,>
L164: 	<identifier, fptr1>
L164: 	<brace, )>
L164: 	<delimeter, ;>
L164: 	<brace, }>
L166: 	<keyword, else>
L167: 	<brace, {>
L167: 	<identifier, HC>
L167: 	<assign-op, =>
L167: 	<identifier, CreateHuffmancode>
L167: 	<brace, (>
L167: 	<identifier, n>
L167: 	<brace, )>
L167: 	<delimeter, ;>
L169: 	<keyword, while>
L169: 	<brace, (>
L169: 	<brace, (>
L169: 	<identifier, i>
L169: 	<assign-op, =>
L169: 	<identifier, fgetc>
L169: 	<brace, (>
L169: 	<identifier, fptr>
L169: 	<brace, )>
L169: 	<brace, )>
L169: 	<relop, !=>
L169: 	<identifier, EOF>
L169: 	<brace, )>
L170: 	<identifier, fputs>
L170: 	<brace, (>
L170: 	<identifier, HC>
L170: 	<brace, [>
L170: 	<identifier, i>
L170: 	<brace, ]>
L170: 	<delimeter, ,>
L170: 	<identifier, fptr0>
L170: 	<brace, )>
L170: 	<delimeter, ;>
L173: 	<identifier, rewind>
L173: 	<brace, (>
L173: 	<identifier, fptr0>
L173: 	<brace, )>
L173: 	<delimeter, ;>
L174: 	<identifier, weight>
L174: 	<assign-op, =>
L174: 	<integer, 128>
L174: 	<delimeter, ;>
L175: 	<identifier, j>
L175: 	<assign-op, =>
L175: 	<integer, 0>
L175: 	<delimeter, ;>
L176: 	<keyword, while>
L176: 	<brace, (>
L176: 	<brace, (>
L176: 	<identifier, i>
L176: 	<assign-op, =>
L176: 	<identifier, fgetc>
L176: 	<brace, (>
L176: 	<identifier, fptr0>
L176: 	<brace, )>
L176: 	<brace, )>
L176: 	<relop, !=>
L176: 	<identifier, EOF>
L176: 	<brace, )>
L177: 	<brace, {>
L177: 	<identifier, j>
L177: 	<arith-op, +=>
L177: 	<brace, (>
L177: 	<identifier, i>
L177: 	<arith-op, ->
L177: 	<integer, 48>
L177: 	<brace, )>
L177: 	<arith-op, *>
L177: 	<identifier, weight>
L177: 	<delimeter, ;>
L178: 	<identifier, weight>
L178: 	<assign-op, =>
L178: 	<identifier, weight>
L178: 	<arith-op, />
L178: 	<integer, 2>
L178: 	<delimeter, ;>
L179: 	<keyword, if>
L179: 	<brace, (>
L179: 	<identifier, weight>
L179: 	<relop, ==>
L179: 	<integer, 0>
L179: 	<brace, )>
L180: 	<brace, {>
L180: 	<identifier, weight>
L180: 	<assign-op, =>
L180: 	<integer, 128>
L180: 	<delimeter, ;>
L181: 	<identifier, fputc>
L181: 	<brace, (>
L181: 	<brace, (>
L181: 	<keyword, unsigned>
L181: 	<keyword, char>
L181: 	<brace, )>
L181: 	<identifier, j>
L181: 	<delimeter, ,>
L181: 	<identifier, fptr1>
L181: 	<brace, )>
L181: 	<delimeter, ;>
L182: 	<identifier, num>
L182: 	<arith-op, ++>
L182: 	<delimeter, ;>
L183: 	<identifier, j>
L183: 	<assign-op, =>
L183: 	<integer, 0>
L183: 	<delimeter, ;>
L183: 	<brace, }>
L184: 	<brace, }>
L185: 	<keyword, if>
L185: 	<brace, (>
L185: 	<identifier, weight>
L185: 	<relop, !=>
L185: 	<integer, 0>
L185: 	<brace, )>
L186: 	<brace, {>
L186: 	<identifier, fputc>
L186: 	<brace, (>
L186: 	<identifier, j>
L186: 	<delimeter, ,>
L186: 	<identifier, fptr1>
L186: 	<brace, )>
L186: 	<delimeter, ;>
L187: 	<identifier, pos>
L187: 	<assign-op, =>
L187: 	<identifier, weight>
L187: 	<delimeter, ;>
L187: 	<brace, }>
L187: 	<brace, }>
L188: 	<identifier, printf>
L188: 	<brace, (>
L188: 	<string, "处理过程如下:\n">
L188: 	<brace, )>
L188: 	<delimeter, ;>
L189: 	<identifier, c>
L189: 	<assign-op, =>
L189: 	<identifier, getchar>
L189: 	<brace, (>
L189: 	<brace, )>
L189: 	<delimeter, ;>
L190: 	<keyword, if>
L190: 	<brace, (>
L190: 	<identifier, c>
L190: 	<relop, ==>
L190: 	<char, 'y'>
L190: 	<brace, )>
L191: 	<keyword, if>
L191: 	<brace, (>
L191: 	<identifier, n>
L191: 	<relop, >>
L191: 	<integer, 1>
L191: 	<brace, )>
L192: 	<brace, {>
L193: 	<identifier, Huffmandecoding>
L193: 	<brace, (>
L193: 	<identifier, fptr1>
L193: 	<delimeter, ,>
L193: 	<identifier, num>
L193: 	<delimeter, ,>
L193: 	<identifier, pos>
L193: 	<delimeter, ,>
L193: 	<identifier, filename>
L193: 	<delimeter, ,>
L193: 	<identifier, filetype>
L193: 	<brace, (>
L193: 	<identifier, filename>
L193: 	<brace, )>
L193: 	<brace, )>
L193: 	<delimeter, ;>
L194: 	<identifier, free>
L194: 	<brace, (>
L194: 	<identifier, HT>
L194: 	<brace, )>
L194: 	<delimeter, ;>
L195: 	<keyword, for>
L195: 	<brace, (>
L195: 	<identifier, i>
L195: 	<assign-op, =>
L195: 	<integer, 0>
L195: 	<delimeter, ;>
L195: 	<identifier, i>
L195: 	<relop, <>
L195: 	<integer, 256>
L195: 	<delimeter, ;>
L195: 	<identifier, i>
L195: 	<arith-op, ++>
L195: 	<brace, )>
L196: 	<identifier, free>
L196: 	<brace, (>
L196: 	<identifier, HC>
L196: 	<brace, [>
L196: 	<identifier, i>
L196: 	<brace, ]>
L196: 	<brace, )>
L196: 	<delimeter, ;>
L197: 	<identifier, free>
L197: 	<brace, (>
L197: 	<identifier, HC>
L197: 	<brace, )>
L197: 	<delimeter, ;>
L197: 	<brace, }>
L198: 	<keyword, else>
L199: 	<brace, {>
L199: 	<identifier, rewind>
L199: 	<brace, (>
L199: 	<identifier, fptr1>
L199: 	<brace, )>
L199: 	<delimeter, ;>
L200: 	<identifier, FILE>
L200: 	<arith-op, *>
L200: 	<identifier, fptr2>
L200: 	<delimeter, ;>
L201: 	<keyword, char>
L201: 	<identifier, objectfile>
L201: 	<brace, [>
L201: 	<integer, 10>
L201: 	<brace, ]>
L201: 	<assign-op, =>
L201: 	<string, "out2">
L201: 	<delimeter, ;>
L202: 	<identifier, strcat>
L202: 	<brace, (>
L202: 	<identifier, objectfile>
L202: 	<delimeter, ,>
L202: 	<bitop, &>
L202: 	<identifier, filename>
L202: 	<brace, [>
L202: 	<identifier, filetype>
L202: 	<brace, (>
L202: 	<identifier, filename>
L202: 	<brace, )>
L202: 	<brace, ]>
L202: 	<brace, )>
L202: 	<delimeter, ;>
L202: 	<delimeter, ;>
L203: 	<keyword, if>
L203: 	<brace, (>
L203: 	<brace, (>
L203: 	<identifier, fptr2>
L203: 	<assign-op, =>
L203: 	<identifier, fopen>
L203: 	<brace, (>
L203: 	<identifier, objectfile>
L203: 	<delimeter, ,>
L203: 	<string, "wb">
L203: 	<brace, )>
L203: 	<brace, )>
L203: 	<relop, ==>
L203: 	<identifier, NULL>
L203: 	<brace, )>
L204: 	<identifier, printf>
L204: 	<brace, (>
L204: 	<string, "can't open the object file\n">
L204: 	<brace, )>
L204: 	<delimeter, ;>
L205: 	<keyword, for>
L205: 	<brace, (>
L205: 	<identifier, i>
L205: 	<assign-op, =>
L205: 	<integer, 0>
L205: 	<delimeter, ;>
L205: 	<identifier, i>
L205: 	<relop, <>
L205: 	<identifier, k>
L205: 	<delimeter, ;>
L205: 	<identifier, i>
L205: 	<arith-op, ++>
L205: 	<brace, )>
L206: 	<identifier, fputc>
L206: 	<brace, (>
L206: 	<identifier, ch>
L206: 	<delimeter, ,>
L206: 	<identifier, fptr2>
L206: 	<brace, )>
L206: 	<delimeter, ;>
L207: 	<identifier, printf>
L207: 	<brace, (>
L207: 	<string, "处理结果写入到out2中">
L207: 	<brace, )>
L207: 	<delimeter, ;>
L208: 	<identifier, fclose>
L208: 	<brace, (>
L208: 	<identifier, fptr2>
L208: 	<brace, )>
L208: 	<delimeter, ;>
L208: 	<brace, }>
L211: 	<identifier, fclose>
L211: 	<brace, (>
L211: 	<identifier, fptr>
L211: 	<brace, )>
L211: 	<delimeter, ;>
L212: 	<identifier, fclose>
L212: 	<brace, (>
L212: 	<identifier, fptr0>
L212: 	<brace, )>
L212: 	<delimeter, ;>
L213: 	<identifier, fclose>
L213: 	<brace, (>
L213: 	<identifier, fptr1>
L213: 	<brace, )>
L213: 	<delimeter, ;>
L214: 	<keyword, return>
L214: 	<integer, 0>
L214: 	<delimeter, ;>
L215: 	<brace, }>
